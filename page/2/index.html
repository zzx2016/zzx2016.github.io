<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Android" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description" content="Androider">
<meta property="og:type" content="website">
<meta property="og:title" content="守心的博客">
<meta property="og:url" content="http://www.in-droid.com/page/2/index.html">
<meta property="og:site_name" content="守心的博客">
<meta property="og:description" content="Androider">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="守心的博客">
<meta name="twitter:description" content="Androider">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> 守心的博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?f461e47d813803e61d6d7378270e0e91";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  <script type="text/javascript">
    (function() {
      var hm = document.createElement("script");
      hm.src = "//tajs.qq.com/stats?sId=55064070";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>






  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">守心的博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">享受生活</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="#" class="st-search-show-outputs">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <form class="site-search-form">
  <input type="text" id="st-search-input" class="st-search-input st-default-search-input" />
</form>

<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install', '8hs2qaVs5P9aBSYqd-Qx','2.0.0');
</script>



    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" target="_blank" href="/2016/05/28/设计模式-行为型-之观察者模式-Observer-Pattern/" itemprop="url">
                  设计模式(行为型)之观察者模式(Observer Pattern)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-28T17:07:51+08:00" content="2016-05-28">
              2016-05-28
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/28/设计模式-行为型-之观察者模式-Observer-Pattern/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/28/设计模式-行为型-之观察者模式-Observer-Pattern/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p><a href="http://blog.csdn.net/yanbober">原文地址</a></p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>观察者模式用于建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应作出反应。在观察者模式中，发生改变的对象称为观察目标，而被通知的对象称为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间可以没有任何相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展。一个软件系统常常要求在某一个对象的状态发生变化的时候，某些其他的对象做出相应的改变。做到这一点的设计方案有很多，但是为了使系统能够易于复用，应该选择低耦合度的设计方案。减少对象之间的耦合有利于系统的复用，但是同时设计师需要使这些低耦合度的对象之间能够维持行动的协调一致，保证高度的协作。观察者模式是满足这一要求的各种设计方案中最重要的一种。</p>
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/05/28/设计模式-行为型-之观察者模式-Observer-Pattern/#more" rel="contents" target="_blank">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" target="_blank" href="/2016/05/28/设计模式-结构型-之代理模式-Proxy-Pattern/" itemprop="url">
                  设计模式(结构型)之代理模式(Proxy Pattern)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-28T17:02:01+08:00" content="2016-05-28">
              2016-05-28
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/28/设计模式-结构型-之代理模式-Proxy-Pattern/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/28/设计模式-结构型-之代理模式-Proxy-Pattern/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://blog.csdn.net/yanbober" target="_blank" rel="external">原文地址</a></p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>代理模式是常用的结构型设计模式之一，当无法直接访问某个对象或访问某个对象存在困难时可以通过一个代理对象来间接访问，为了保证客户端使用的透明性，所访问的真实对象与代理对象需要实现相同的接口。根据代理模式的使用目的不同，代理模式又可以分为多种类型，例如保护代理、远程代理、虚拟代理、缓冲代理等，它们应用于不同的场合，满足用户的不同需求。</p>
<h3 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h3><p><strong>概念：</strong> 给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。</p>
<p><strong>代理模式结构重要核心模块：</strong></p>
<ol>
<li><p>Subject（抽象主题角色）</p>
<p>它声明了真实主题和代理主题的共同接口，这样一来在任何使用真实主题的地方都可以使用代理主题，客户端通常需要针对抽象主题角色进行编程。</p>
</li>
<li><p>Proxy（代理主题角色）</p>
<p>它包含了对真实主题的引用，从而可以在任何时候操作真实主题对象；在代理主题角色中提供一个与真实主题角色相同的接口，以便在任何时候都可以替代真实主题；代理主题角色还可以控制对真实主题的使用，负责在需要的时候创建和删除真实主题对象，并对真实主题对象的使用加以约束。通常，在代理主题角色中，客户端在调用所引用的真实主题操作之前或之后还需要执行其他操作，而不仅仅是单纯调用真实主题对象中的操作。</p>
</li>
<li><p>RealSubject（真实主题角色）</p>
<p>它定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接调用真实主题角色中定义的操作。</p>
</li>
</ol>
<h3 id="代理模式分类："><a href="#代理模式分类：" class="headerlink" title="代理模式分类："></a>代理模式分类：</h3><p>代理模式根据其目的和实现方式不同可分为很多种类，其中常用的几种代理模式简要说明如下：</p>
<ol>
<li><p>远程代理(Remote Proxy)</p>
<p>给一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可是在另一台主机中，远程代理又称为大使(Ambassador)。</p>
</li>
<li><p>虚拟代理(Virtual Proxy)</p>
<p>如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。</p>
</li>
<li><p>保护代理(Protect Proxy)</p>
<p>控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。</p>
</li>
<li><p>缓冲代理(Cache Proxy)</p>
<p>为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。</p>
</li>
<li><p>智能引用代理(Smart Reference Proxy)</p>
<p>当一个对象被引用时，提供一些额外的操作，例如将对象被调用的次数记录下来等。</p>
</li>
</ol>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>代理模式的类型较多，不同类型的代理模式有不同的优缺点，它们应用于不同的场合：</p>
<p>当客户端对象需要访问远程主机中的对象时可以使用远程代理。</p>
<p>当需要用一个消耗资源较少的对象来代表一个消耗资源较多的对象，从而降低系统开销、缩短运行时间时可以使用虚拟代理，例如一个对象需要很长时间才能完成加载时。</p>
<p>当需要为某一个被频繁访问的操作结果提供一个临时存储空间，以供多个客户端共享访问这些结果时可以使用缓冲代理。通过使用缓冲代理，系统无须在客户端每一次访问时都重新执行操作，只需直接从临时缓冲区获取操作结果即可。</p>
<p>当需要控制对一个对象的访问，为不同用户提供不同级别的访问权限时可以使用保护代理。</p>
<p>当需要为一个对象的访问（引用）提供一些额外的操作时可以使用智能引用代理。</p>
<h3 id="程序猿实例"><a href="#程序猿实例" class="headerlink" title="程序猿实例"></a>程序猿实例</h3><p>简单的实例：</p>
<p>如下图片结构就是一个代理模式的UML图：</p>
<p><img src="" alt="picture"></p>
<p>如下是一个入门代理模式的简单示例，遵循了代理模式的几大核心模块。我们以程序猿买 港版MacBook为例来说明代理模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象对象角色</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IMacBook</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buyIt</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//目标对象角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HangKangMacBook</span> <span class="keyword">implements</span> <span class="title">IMacBook</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyIt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"This computer is from HangKang!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代理对象角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyMacBook</span> <span class="keyword">implements</span> <span class="title">IMacBook</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyIt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HangKangMacBook mac = <span class="keyword">new</span> HangKangMacBook();</span><br><span class="line">        mac.buyIt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IMacBook macBook = <span class="keyword">new</span> ProxyMacBook();</span><br><span class="line">        macBook.buyIt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>在Android中的一个代理模式运用实例：</strong></p>
<p>在Android中代理模式也是使用广泛的，例如ActivityManagerProxy类就是一个代理，它是ActivityManagerNative的代理，也就是说ActivityManagerProxy是上面所说的Proxy类，而ActivityManagerNative就相当于RealSubject类，它们都有一个共有的接口IActivityManager。在这里还有一个重要的类：ActivityManager，它相当于代理模式的类图中的client。在这个类中，可以看到大量的getxxx函数，这些函数，都会调用到ActivityManagerNative类的getDefault()方法，而该方法会获得一个共用的单例的IActivityManager引用，然后通过多态来调用代理中的实现。</p>
<h3 id="总结一把"><a href="#总结一把" class="headerlink" title="总结一把"></a>总结一把</h3><h4 id="代理模式优点："><a href="#代理模式优点：" class="headerlink" title="代理模式优点："></a>代理模式优点：</h4><ul>
<li>能够协调调用者和被调用者，在一定程度上降低了系统的耦合度。</li>
<li>客户端可以针对抽象主题角色进行编程，增加和更换代理类无须修改源代码，符合开闭原则，系统具有较好的灵活性和可扩展性。</li>
<li>远程代理为位于两个不同地址空间对象的访问提供了一种实现机制，可以将一些消耗资源较多的对象和操作移至性能更好的计算机上，提高系统的整体运行效率。</li>
<li>虚拟代理通过一个消耗资源较少的对象来代表一个消耗资源较多的对象，可以在一定程度上节省系统的运行开销。</li>
<li>缓冲代理为某一个操作的结果提供临时的缓存存储空间，以便在后续使用中能够共享这些结果，优化系统性能，缩短执行时间。</li>
<li>保护代理可以控制对一个对象的访问权限，为不同用户提供不同级别的使用权限。</li>
</ul>
<h4 id="代理模式缺点："><a href="#代理模式缺点：" class="headerlink" title="代理模式缺点："></a>代理模式缺点：</h4><ul>
<li>由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢，例如保护代理。</li>
<li>实现代理模式需要额外的工作，而且有些代理模式的实现过程较为复杂，例如远程代理。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" target="_blank" href="/2016/05/28/设计模式-结构型-之享元模式-Flyweight-Pattern/" itemprop="url">
                  设计模式(结构型)之享元模式(Flyweight Pattern)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-28T16:53:31+08:00" content="2016-05-28">
              2016-05-28
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/28/设计模式-结构型-之享元模式-Flyweight-Pattern/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/28/设计模式-结构型-之享元模式-Flyweight-Pattern/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p><a href="http://blog.csdn.net/yanbober">原文地址</a></p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>当一个软件系统在运行时产生的对象数量太多，将导致运行代价过高，带来系统性能下降等问题。所以需要采用一个共享来避免大量拥有相同内容对象的开销。在Java中，String类型就是使用了享元模式。String对象是final类型，对象一旦创建就不可改变。在Java中字符串常量都是存在常量池中的，Java会确保一个字符串常量在常量池中只有一个拷贝。</p>
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/05/28/设计模式-结构型-之享元模式-Flyweight-Pattern/#more" rel="contents" target="_blank">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" target="_blank" href="/2016/05/28/设计模式-结构型-之外观模式-Facade-Pattern/" itemprop="url">
                  设计模式(结构型)之外观模式(Facade Pattern)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-28T16:51:13+08:00" content="2016-05-28">
              2016-05-28
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/28/设计模式-结构型-之外观模式-Facade-Pattern/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/28/设计模式-结构型-之外观模式-Facade-Pattern/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://blog.csdn.net/yanbober" target="_blank" rel="external">原文地址</a></p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>一个客户类需要和多个业务类交互，而这些业务类经常会作为整体出现，由于涉及到的类比较多，导致使用时代码较为复杂。外观模式通过引入一个新的外观类(Facade)来实现该功能，外观类为多个业务类的调用提供统一入口，简化了类与类之间的交互。如果没有外观类，那么每个客户类需要和多个业务类之间进行复杂的交互，系统的耦合度将很大。外观模式是迪米特法则的一种具体实现，通过引入一个新的外观角色可以降低原有系统的复杂度，同时降低客户类与子系统的耦合度。</p>
<h3 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h3><p><strong>概念：</strong> 为子系统中的一组接口提供一个统一的入口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p>
<p><strong>重点：</strong> 外观模式结构重要核心模块：</p>
<ol>
<li><p>外观角色</p>
<p>客户端可以调用它的方法，在外观角色中可以知道相关子系统的功能和责任；在正常情况下，它将所有从客户端发来的请求委派到相应的子系统去，传递给相应的子系统对象处理。</p>
</li>
<li><p>子系统角色</p>
<p>在软件系统中可以有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能；每一个子系统都可以被客户端直接调用，或者被外观角色调用，它处理由外观类传过来的请求；子系统并不知道外观的存在，对于子系统而言，外观角色仅仅是另外一个客户端而已。</p>
</li>
</ol>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>需要访问一系列复杂的子系统时提供一个简单入口。</p>
<p>客户端程序与多个子系统之间存在很大的依赖性。引入外观类可以将子系统与客户端解耦，从而提高子系统的独立性和可移植性。</p>
<p>在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度。</p>
<h3 id="程序猿实例"><a href="#程序猿实例" class="headerlink" title="程序猿实例"></a>程序猿实例</h3><p>这里还是以苦逼的程序猿为例来说明外观模式。一个Android开发者开发Android程序需要很多工具条件，电脑，软件，网络。如下实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子系统角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">thinkpad</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Computer is ThinkPad!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EathNet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">net</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Net is CMCC!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeveloperTools</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tools</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Developer Tool is Android Studio!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//外观角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AndroidDeveloperEquipment</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">equipment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Computer().thinkpad();</span><br><span class="line">        <span class="keyword">new</span> EathNet().net();</span><br><span class="line">        <span class="keyword">new</span> DeveloperTools().tools();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AndroidDeveloperEquipment dev = <span class="keyword">new</span> AndroidDeveloperEquipment();</span><br><span class="line">        dev.equipment();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结一把"><a href="#总结一把" class="headerlink" title="总结一把"></a>总结一把</h3><h4 id="外观模式优点："><a href="#外观模式优点：" class="headerlink" title="外观模式优点："></a>外观模式优点：</h4><ul>
<li>减少客户端所需处理的对象数目，使得子系统使用起来更加容易。</li>
<li>实现了子系统与客户端之间的松耦合关系。</li>
<li>一个子系统的修改对其他子系统没有任何影响，而且子系统内部变化也不会影响到外观对象。</li>
</ul>
<h4 id="外观模式缺点："><a href="#外观模式缺点：" class="headerlink" title="外观模式缺点："></a>外观模式缺点：</h4><ul>
<li>不能很好地限制客户端直接使用子系统类，如果对客户端访问子系统类做太多的限制则减少了可变性和灵活性。</li>
<li>如果设计不当，增加新的子系统可能需要修改外观类的源代码，违背了开闭原则。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" target="_blank" href="/2016/05/28/设计模式-结构型-之装饰者模式-Decorator-Pattern/" itemprop="url">
                  设计模式(结构型)之装饰者模式(Decorator Pattern)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-28T16:47:50+08:00" content="2016-05-28">
              2016-05-28
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/28/设计模式-结构型-之装饰者模式-Decorator-Pattern/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/28/设计模式-结构型-之装饰者模式-Decorator-Pattern/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p><a href="http://blog.csdn.net/yanbober">原文地址</a></p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>装饰模式可以在不改变一个对象本身功能的基础上给对象增加额外的新行为。装饰模式是一种用于替代继承的技术，它通过一种无须定义子类的方式来给对象动态增加职责，使用对象之间的关联关系取代类之间的继承关系。在装饰模式中引入了装饰类，在装饰类中既可以调用待装饰的原有类的方法，还可以增加新的方法，以扩充原有类的功能。</p>
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/05/28/设计模式-结构型-之装饰者模式-Decorator-Pattern/#more" rel="contents" target="_blank">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" target="_blank" href="/2016/05/28/设计模式-结构型-之组合模式-Composite-Pattern/" itemprop="url">
                  设计模式(结构型)之组合模式(Composite Pattern)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-28T16:43:22+08:00" content="2016-05-28">
              2016-05-28
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/28/设计模式-结构型-之组合模式-Composite-Pattern/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/28/设计模式-结构型-之组合模式-Composite-Pattern/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p><a href="http://blog.csdn.net/yanbober">原文地址</a></p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>组合模式又叫做部分-整体模式，使我们在树型结构的问题中模糊简单元素和复杂元素的概念，客户程序可以像处理简单元素一样来处理复杂的元素，从而使得客户程序与复杂元素的内部结构解耦。组合模式可以优化处理递归或分级数据结构。有许多关于分级数据结构的例子，使得组合模式非常有用武之地。</p>
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/05/28/设计模式-结构型-之组合模式-Composite-Pattern/#more" rel="contents" target="_blank">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" target="_blank" href="/2016/05/28/设计模式-结构型-之桥接模式-Bridge-Pattern/" itemprop="url">
                  设计模式(结构型)之桥接模式(Bridge Pattern)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-28T16:37:46+08:00" content="2016-05-28">
              2016-05-28
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/28/设计模式-结构型-之桥接模式-Bridge-Pattern/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/28/设计模式-结构型-之桥接模式-Bridge-Pattern/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p><a href="http://blog.csdn.net/yanbober">原文地址</a></p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>桥接模式是一种很实用的结构型设计模式，如果软件系统中某个类存在多个独立变化的维度，通过该模式可以将这多个维度分离出来，使他们可以独立扩展，让系统更加符合“单一职责原则”。与多层继承方案不同，它将多个独立变化的维度设计为多个独立的继承等级结构，并且在抽象层建立一个抽象关联，该关联关系类似一条连接多个独立继承结构的桥，故名桥接模式。桥接模式用一种巧妙的方式处理多层继承存在的问题，用抽象关联取代了传统的多层继承，将类之间的静态继承关系转换为动态的对象组合关系，使得系统更加灵活，并易于扩展，同时有效控制了系统中类的个数。</p>
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/05/28/设计模式-结构型-之桥接模式-Bridge-Pattern/#more" rel="contents" target="_blank">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" target="_blank" href="/2016/05/28/设计模式-创建型-之原型模式-Prototype-Pattern/" itemprop="url">
                  设计模式(创建型)之原型模式(Prototype Pattern)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-28T16:32:30+08:00" content="2016-05-28">
              2016-05-28
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/28/设计模式-创建型-之原型模式-Prototype-Pattern/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/28/设计模式-创建型-之原型模式-Prototype-Pattern/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p><a href="http://blog.csdn.net/yanbober">原文地址</a></p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>要理解原型原型模式必须先理解Java里的浅复制和深复制。有的地方，复制也叫做克隆。Java提供这两种克隆方式。 因为Java中的提供clone()方法来实现对象的克隆,所以Prototype模式实现一下子变得很简单。</p>
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/05/28/设计模式-创建型-之原型模式-Prototype-Pattern/#more" rel="contents" target="_blank">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" target="_blank" href="/2016/05/28/设计模式-结构型-之适配器模式-Adapter-Pattern/" itemprop="url">
                  设计模式(结构型)之适配器模式(Adapter Pattern)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-28T16:24:57+08:00" content="2016-05-28">
              2016-05-28
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/28/设计模式-结构型-之适配器模式-Adapter-Pattern/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/28/设计模式-结构型-之适配器模式-Adapter-Pattern/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://blog.csdn.net/yanbober" target="_blank" rel="external">原文地址</a></p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以在一起工作。即Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以在一起工作。</p>
<h3 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h3><p><strong>概念：</strong> 将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。</p>
<p><strong>分类：</strong> 根据适配器类与适配者类的关系不同，适配器模式可分为对象适配器和类适配器两种。在对象适配器模式中，适配器与适配者之间是关联关系；在类适配器模式中，适配器与适配者之间是继承（或实现）关系。</p>
<p><strong>重点：</strong></p>
<ul>
<li><p>对象适配器模式结构重要核心模块：</p>
<ol>
<li>目标接口（Target）</li>
<li>客户所期待的接口。目标可以是具体的或抽象的类，也可以是接口。</li>
<li>需要适配的类（Adaptee）</li>
<li>需要适配的类或适配者类。</li>
<li>适配器（Adapter）</li>
</ol>
<p>通过包装一个需要适配的对象，把原接口转换成目标接口。</p>
</li>
<li><p>类适配器模式结构重要核心模块：</p>
<ol>
<li>目标接口（Target）</li>
<li>客户所期待的接口。目标是接口。</li>
<li>需要适配的类（Adaptee）</li>
<li>需要适配的类或适配者类。</li>
<li>适配器（Adapter）</li>
<li>适配器类实现了抽象目标类接口Target，并继承了适配者类Adaptee。</li>
</ol>
<p>类适配器模式中如果适配者Adapter为最终(Final)类，也无法使用类适配器。在Java等面向对象编程语言中，大部分情况下我们使用的是对象适配器，类适配器较少使用。</p>
</li>
</ul>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>系统需要使用现有的类，而这些类的接口不符合系统的接口。</p>
<p>想要建立一个可以重用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。</p>
<p>两个类所做的事情相同或相似，但是具有不同接口的时候。</p>
<p>旧的系统开发的类已经实现了一些功能，但是客户端却只能以另外接口的形式访问，但我们不希望手动更改原有类的时候。</p>
<p>使用第三方组件，组件接口定义和自己定义的不同，不希望修改自己的接口，但是要使用第三方组件接口的功能。</p>
<h3 id="程序猿实例"><a href="#程序猿实例" class="headerlink" title="程序猿实例"></a>程序猿实例</h3><h4 id="对象适配器模式-的代码实例："><a href="#对象适配器模式-的代码实例：" class="headerlink" title="对象适配器模式 的代码实例："></a>对象适配器模式 的代码实例：</h4><p>该例假设了原来有一个程序猿MonkeyAndroidAdaptee精通（只会）Android开发，后来有一天这个程序猿走了，写的代码还在，公司重新招来一个牛逼的全栈程序猿，但是这个牛逼的全栈程序猿首要任务就是维护精通原来离职程序猿的技能，准么办？全栈程序猿只能适配原来Android高手的代码，不能将自己其他的IOS、PHP等技能展示，所以MonkeyHoleTarget的codingAll技能需要适配为专攻的”Can code Android!”技能。这就是一个典型的对象适配器模式（对象在SkillAdapter适配器类中作为成员属性）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//目标接口（Target）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MonkeyHoleTarget</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">codingAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Can code all Language!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//需要适配的类（Adaptee）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MonkeyAndroidAdaptee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">codingAndroid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Can code Android!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//适配器（Adapter）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SkillAdapter</span> <span class="keyword">extends</span> <span class="title">MonkeyHoleTarget</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MonkeyAndroidAdaptee mMonkeyAndroidAdaptee;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SkillAdapter</span><span class="params">(MonkeyAndroidAdaptee target)</span> </span>&#123;</span><br><span class="line">        mMonkeyAndroidAdaptee = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">codingAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mMonkeyAndroidAdaptee.codingAndroid();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MonkeyHoleTarget monkeyHoleTarget = <span class="keyword">new</span> SkillAdapter(<span class="keyword">new</span> MonkeyAndroidAdaptee());</span><br><span class="line">        monkeyHoleTarget.codingAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="类适配器模式-的代码实例："><a href="#类适配器模式-的代码实例：" class="headerlink" title="类适配器模式 的代码实例："></a>类适配器模式 的代码实例：</h4><p>具体代码含义和上面类似。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//目标接口（Target）</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MonkeyHoleTarget</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">codingAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//需要适配的类（Adaptee）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MonkeyAndroidAdaptee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">codingAndroid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Can code Android!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//适配器（Adapter）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SkillAdapter</span> <span class="keyword">implements</span> <span class="title">MonkeyHoleTarget</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MonkeyAndroidAdaptee mMonkeyAndroidAdaptee;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SkillAdapter</span><span class="params">(MonkeyAndroidAdaptee mMonkeyAndroidAdaptee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mMonkeyAndroidAdaptee = mMonkeyAndroidAdaptee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">codingAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mMonkeyAndroidAdaptee.codingAndroid();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MonkeyHoleTarget monkeyHoleTarget = <span class="keyword">new</span> SkillAdapter(<span class="keyword">new</span> MonkeyAndroidAdaptee());</span><br><span class="line">        monkeyHoleTarget.codingAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="升级一把"><a href="#升级一把" class="headerlink" title="升级一把"></a>升级一把</h3><p>适配器模式除了上面介绍的以外还有一个更加牛逼常用的变体（基因突变啊）！如下所述：</p>
<h4 id="缺省适配器模式-Default-Adapter-Pattern"><a href="#缺省适配器模式-Default-Adapter-Pattern" class="headerlink" title="缺省适配器模式(Default Adapter Pattern)"></a>缺省适配器模式(Default Adapter Pattern)</h4><p>当不需要实现一个接口所提供的所有方法时，可先设计一个抽象类实现该接口，并为接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可以选择性地覆盖父类的某些方法来实现需求，它适用于不想使用一个接口中的所有方法的情况，又称为单接口适配器模式。</p>
<h4 id="缺省适配器模式重要核心模块："><a href="#缺省适配器模式重要核心模块：" class="headerlink" title="缺省适配器模式重要核心模块："></a>缺省适配器模式重要核心模块：</h4><ol>
<li><p>ServiceInterface（适配者接口）</p>
<p>它是一个接口，通常在该接口中声明了大量的方法。</p>
</li>
<li><p>AbstractServiceClass（缺省适配器类）</p>
<p>它是缺省适配器模式的核心类，使用空方法的形式实现了在ServiceInterface接口中声明的方法。通常将它定义为抽象类，因为对它进行实例化没有任何意义。</p>
</li>
<li><p>ConcreteServiceClass（具体业务类）</p>
<p>它是缺省适配器类的子类，在没有引入适配器之前，它需要实现适配者接口，因此需要实现在适配者接口中定义的所有方法，而对于一些无须使用的方法也不得不提供空实现。在有了缺省适配器之后，可以直接继承该适配器类，根据需要有选择性地覆盖在适配器类中定义的方法。</p>
</li>
</ol>
<h4 id="代码实战一把"><a href="#代码实战一把" class="headerlink" title="代码实战一把"></a>代码实战一把</h4><p>如下演示了缺省适配器的代码示例，技能太多，所以只关心自己要的技能，具体不说了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//目标接口（Target）</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MonkeyHoleTarget</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">codingAll</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">codingAndroid</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">codingIOS</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">codingPHP</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">codingCLanguage</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">codingScriptShell</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//默认适配器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseAdapter</span> <span class="keyword">implements</span> <span class="title">MonkeyHoleTarget</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">codingAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">codingAndroid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">codingIOS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">codingPHP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">codingCLanguage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">codingScriptShell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//需要适配的类（Adaptee）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MonkeyAndroidAdaptee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">codingAndroid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Can code Android!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//适配器（Adapter）只关心自己感兴趣的部分方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SkillAdapter</span> <span class="keyword">extends</span> <span class="title">BaseAdapter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MonkeyAndroidAdaptee mMonkeyAndroidAdaptee;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SkillAdapter</span><span class="params">(MonkeyAndroidAdaptee mMonkeyAndroidAdaptee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mMonkeyAndroidAdaptee = mMonkeyAndroidAdaptee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">codingAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mMonkeyAndroidAdaptee.codingAndroid();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MonkeyHoleTarget monkeyHoleTarget = <span class="keyword">new</span> SkillAdapter(<span class="keyword">new</span> MonkeyAndroidAdaptee());</span><br><span class="line">        monkeyHoleTarget.codingAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结一把"><a href="#总结一把" class="headerlink" title="总结一把"></a>总结一把</h3><h4 id="适配器模式优点："><a href="#适配器模式优点：" class="headerlink" title="适配器模式优点："></a>适配器模式优点：</h4><ul>
<li>将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构。</li>
<li>增加了类的透明性和复用性，将具体的业务实现过程封装在适配者类中，对于客户端类而言是透明的，而且提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用。</li>
<li>灵活性和扩展性都非常好，可以很方便地更换适配器。</li>
<li>一个对象适配器可以把多个不同的适配者适配到同一个目标。</li>
<li>可以适配一个适配者的子类，由于适配器和适配者之间是关联关系，根据“里氏代换原则”，适配者的子类也可通过该适配器进行适配。</li>
</ul>
<h4 id="适配器模式缺点："><a href="#适配器模式缺点：" class="headerlink" title="适配器模式缺点："></a>适配器模式缺点：</h4><ul>
<li>类适配器模式对于不支持多重类继承的语言，一次最多只能适配一个适配者类，不能同时适配多个适配者。</li>
<li>适配者类不能为最终类，如在Java中不能为final类。</li>
<li>在Java中，类适配器模式中的目标抽象类只能为接口，不能为类，其使用有一定的局限性。</li>
<li>对象适配器要在适配器中置换适配者类的某些方法比较麻烦。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" target="_blank" href="/2016/05/28/设计模式-创建型-之建造者模式-Builder-Pattern/" itemprop="url">
                  设计模式(创建型)之建造者模式(Builder Pattern)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-28T16:17:27+08:00" content="2016-05-28">
              2016-05-28
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/28/设计模式-创建型-之建造者模式-Builder-Pattern/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/28/设计模式-创建型-之建造者模式-Builder-Pattern/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p><a href="http://blog.csdn.net/yanbober">原文地址</a></p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>建造者模式将客户端与包含多个组成部分的复杂对象的创建过程分离，客户端压根不用知道复杂对象的内部组成部分与装配方式，只需要知道所需建造者的类型即可。它关注如何一步一步创建一个的复杂对象，不同的具体建造者定义了不同的创建过程，且具体建造者相互独立，增加新的建造者非常方便，无须修改已有代码，系统具有较好的扩展性。</p>
<p>问题来了。。。</p>
<p>你可能会有疑惑，建造者模式和抽象工厂模式有啥区别呢？</p>
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/05/28/设计模式-创建型-之建造者模式-Builder-Pattern/#more" rel="contents" target="_blank">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/default_avatar.jpg"
               alt="zhangzixu" />
          <p class="site-author-name" itemprop="name">zhangzixu</p>
          <p class="site-description motion-element" itemprop="description">Androider</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">59</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">16</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/zzx2016" target="_blank">
                  
                    <i class="fa fa-github"></i> GitHub
                  
                </a>
              </span>
            
          
        </div>

        
        

        
        <div class="links-of-blogroll motion-element">
          
            <div class="links-of-blogroll-title">常用工具</div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.w3school.com.cn/" target="_blank">w3school</a>
                </li>
              
            </ul>
          
        </div>

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhangzixu</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  


  




<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"zhangzixu"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  





  
  
  

  


</body>
</html>
